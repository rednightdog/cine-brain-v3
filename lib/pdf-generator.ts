// @ts-ignore
import PDFDocument from 'pdfkit/js/pdfkit.standalone';
import blobStream from 'blob-stream';

export type PDFItem = {
    name: string;
    brand: string;
    model?: string | null;
    series?: string | null;
    level: number; // 0 for root, 1+ for children
    assignedCam?: string;
    category?: string;
    sensor_size?: string | null;
    weight_kg?: number | null;
    front_diameter_mm?: number | null;
    quantity?: number;
    specs_json?: string | null;
};

export type ProjectData = {
    name: string;
    productionCo?: string | null;
    producer?: string | null;
    director?: string | null;
    cinematographer?: string | null;
    assistantCamera?: string | null;
    rentalHouse?: string | null;
    contactsJson?: string | null;
    datesJson?: string | null;
    version?: number;
};

export async function generateCineListPDF(data: PDFItem[], project: ProjectData | null): Promise<string> {

    // --- PRE-LOAD FONTS ---
    // Fetch fonts and convert to Buffer for PDFKit
    // NOTE: We must check if fetch was successful, otherwise we might get HTML error page
    const loadFont = async (url: string) => {
        const res = await fetch(url);
        if (!res.ok) throw new Error(`Failed to load font from ${url}: ${res.statusText}`);
        const ab = await res.arrayBuffer();
        return Buffer.from(ab);
    };

    const [fontRegular, fontBold] = await Promise.all([
        loadFont('/fonts/Inter-Regular.ttf'),
        loadFont('/fonts/Inter-Bold.ttf')
    ]);

    return new Promise((resolve, reject) => {
        try {
            // Reduce bottom margin to allow footer without auto-paging
            const doc = new PDFDocument({
                size: 'A4',
                margins: { top: 40, bottom: 20, left: 40, right: 40 },
                // @ts-ignore
                autoPaging: false // DISABLE AUTO PAGING
            });
            const stream = doc.pipe(blobStream());

            // --- FONTS ---
            // Register loaded Buffers
            doc.registerFont('Inter', fontRegular);
            doc.registerFont('Inter-Bold', fontBold);

            // --- LAYOUT CONSTANTS ---
            const LEFT_MARGIN = 40;
            const RIGHT_MARGIN = 550;
            const CONTENT_WIDTH = RIGHT_MARGIN - LEFT_MARGIN;

            // --- COLORS & STYLES ---
            const COLOR_GREY_LIGHT = '#A1A1A6'; // Even lighter for subtle text
            const COLOR_GREY_MEDIUM = '#3A3A3C'; // Softer black
            const COLOR_ACCENT = '#000000'; // Pure black for crisp titles
            const COLOR_BORDER = '#E5E5EA'; // Very light border

            const CAM_COLORS: Record<string, string> = {
                'A': '#FF3B30',
                'B': '#007AFF',
                'C': '#FFCC00',
            };

            // --- HEADER ---
            let currentY = 40;
            doc.fontSize(7).font('Inter').fillColor(COLOR_GREY_LIGHT);
            doc.text(`CINEBRAIN â€¢ CAMERA REPORT â€¢ V${project?.version || 1}`, LEFT_MARGIN, currentY, { characterSpacing: 2 });
            doc.text('CAMERA EQUIPMENT ORDER', LEFT_MARGIN, currentY, { align: 'right', width: CONTENT_WIDTH, characterSpacing: 2 });

            currentY += 30;

            // --- FOOTER FUNCTION ---
            let isRenderingFooter = false;
            const renderFooter = () => {
                if (isRenderingFooter) return;
                isRenderingFooter = true;
                const savedY = doc.y;
                const bottomY = 800; // Footer higher to be safe
                doc.fontSize(6).font('Inter').fillColor(COLOR_GREY_LIGHT);
                doc.text('GENERATED BY CINEBRAIN PRO', LEFT_MARGIN, bottomY, {
                    align: 'right',
                    width: CONTENT_WIDTH,
                    characterSpacing: 2,
                    lineBreak: false
                });
                doc.y = savedY;
                isRenderingFooter = false;
            };

            // Render on first page
            renderFooter();

            // Render on every subsequent page
            doc.on('pageAdded', () => {
                renderFooter();
            });

            // Metadata grid (Luxury Style: All Caps Labels, Normal Values)
            let shootDates = "TBD";
            if (project?.datesJson) {
                try {
                    const d = JSON.parse(project.datesJson);
                    if (d.shoot?.start) shootDates = `${d.shoot.start} â€” ${d.shoot.end || '...'}`;
                } catch (e) { }
            }

            const metaFields = [
                { label: "PROJECT", value: project?.name },
                { label: "PRODUCTION", value: project?.productionCo },
                { label: "RENTAL HOUSE", value: project?.rentalHouse },
                { label: "DP", value: project?.cinematographer },
                { label: "1ST AC", value: project?.assistantCamera },
                { label: "DATES", value: shootDates },
            ];

            doc.fontSize(8);
            const LABEL_WIDTH = 90;
            const VALUE_X = LEFT_MARGIN + LABEL_WIDTH;

            metaFields.forEach(field => {
                if (!field.value) return;

                const isProjectName = field.label === "PROJECT" || field.label === "PROJECT NAME";

                // Calculate height based on content
                const labelH = doc.heightOfString(field.label, { width: LABEL_WIDTH });
                const valueW = 330;
                // Use slightly larger font for project name (10pt instead of 14pt)
                if (isProjectName) doc.fontSize(10);
                else doc.fontSize(8);

                const valueH = doc.heightOfString(field.value, { width: valueW });

                // Reset font size for row height calculation baseline if needed, 
                // but actually we want the max of headers. 
                const rowH = Math.max(labelH, valueH);

                // Delicate All-Caps Label (Standard for all)
                doc.fontSize(8).font('Inter').fillColor(COLOR_GREY_LIGHT).text(field.label.toUpperCase(), LEFT_MARGIN, currentY + (isProjectName ? 2 : 0), { width: LABEL_WIDTH, characterSpacing: 1 });

                // Value Styling
                if (isProjectName) {
                    // Project Name: Slightly Larger, "Elegant Gray" (Matches Headers), Elegant Spacing
                    doc.fontSize(10).font('Inter').fillColor(COLOR_GREY_LIGHT).text(field.value, VALUE_X, currentY, { width: valueW, characterSpacing: 1.5 });
                } else {
                    // Standard Value: Crisp, Medium Color
                    doc.fontSize(8).font('Inter').fillColor(COLOR_GREY_MEDIUM).text(field.value, VALUE_X, currentY, { width: valueW });
                }

                currentY += rowH + 6;

                // Reset font size just in case for next loop iteration stability (though we set it explicitly)
                doc.fontSize(8);
            });

            currentY += 15;
            doc.moveTo(LEFT_MARGIN, currentY).lineTo(RIGHT_MARGIN, currentY).strokeColor(COLOR_BORDER).lineWidth(0.2).stroke();
            currentY += 20;

            // --- DATA PREPARATION ---
            const categories = [
                { id: 'CAM', label: 'CAMERAS' },
                { id: 'LNS', label: 'LENSES' },
                { id: 'SUP', label: 'SUPPORT' },
                { id: 'LIT', label: 'LIGHTING' },
                { id: 'MISC', label: 'OTHER' }
            ];

            // --- RENDER SECTIONS ---
            doc.y = currentY;

            categories.forEach(cat => {
                const catItems = data.filter(i => (i.category === cat.id || (cat.id === 'MISC' && !i.category)));
                if (catItems.length === 0) return;

                // Category Header (Thin, Spaced, All-Caps)
                if (doc.y > 700) doc.addPage().y = 40;
                doc.moveDown(1.5);
                doc.fontSize(7).font('Inter').fillColor(COLOR_GREY_LIGHT).text(cat.label, LEFT_MARGIN, doc.y, { characterSpacing: 3 });
                doc.moveDown(0.5);

                // Group by Cam within category
                const camUnits = Array.from(new Set(catItems.map(i => i.assignedCam || 'A'))).sort();

                camUnits.forEach(unit => {
                    const unitItems = catItems.filter(i => (i.assignedCam || 'A') === unit);
                    if (unitItems.length === 0) return;

                    // Camera Unit Sub-Header (Elegant Line + Label)
                    if (doc.y > 720) doc.addPage().y = 40;

                    doc.moveDown(0.5);
                    const badgeColor = CAM_COLORS[unit] || '#8E8E93';

                    // Simple, elegant indicator instead of blocky badge
                    doc.moveTo(LEFT_MARGIN, doc.y + 10).lineTo(LEFT_MARGIN + 20, doc.y + 10).strokeColor(badgeColor).lineWidth(1.5).stroke();
                    doc.fontSize(8).font('Inter-Bold').fillColor(COLOR_GREY_MEDIUM).text(`UNIT ${unit}`, LEFT_MARGIN + 25, doc.y + 3, { characterSpacing: 1 });
                    doc.moveDown(1);

                    if (cat.id === 'LNS') {
                        // --- ADVANCED LENS GROUPING ---
                        const lensGroups: Record<string, PDFItem[]> = {};
                        unitItems.forEach(i => {
                            const gKey = `${i.brand} ${i.series || 'Other'}`;
                            if (!lensGroups[gKey]) lensGroups[gKey] = [];
                            lensGroups[gKey].push(i);
                        });

                        Object.entries(lensGroups).forEach(([seriesKey, items]) => {
                            if (doc.y > 750) doc.addPage().y = 40;

                            const first = items[0];
                            const startY = doc.y;

                            // Series Title (Crisp, not bold)
                            doc.fontSize(9).font('Inter').fillColor(COLOR_ACCENT).text(seriesKey.toUpperCase(), LEFT_MARGIN, startY, { characterSpacing: 0.5 });

                            // Specs on same line
                            const specs: string[] = [];
                            if (first.sensor_size) specs.push(first.sensor_size.toLowerCase());
                            if (first.weight_kg) specs.push(`${first.weight_kg}kg`);
                            if (first.front_diameter_mm) specs.push(`${first.front_diameter_mm}mm`);

                            if (specs.length > 0) {
                                const titleW = doc.widthOfString(seriesKey.toUpperCase(), { characterSpacing: 0.5 });
                                doc.fontSize(7).font('Inter').fillColor(COLOR_GREY_LIGHT).text(specs.join(' â€¢ '), LEFT_MARGIN + titleW + 10, startY + 2);
                            }

                            doc.moveDown(0.2);

                            // Focal Lengths (Delicate list)
                            const focalLengths = items.map(i => {
                                const qtySuffix = (i.quantity || 1) > 1 ? ` (x${i.quantity})` : '';
                                return i.name.replace(seriesKey, '').replace(i.brand, '').trim() + qtySuffix;
                            }).join('   /   '); // Chanel-style slash separator

                            doc.fontSize(8).font('Inter').fillColor(COLOR_GREY_MEDIUM).text(focalLengths, LEFT_MARGIN + 5, doc.y);

                            doc.moveDown(0.5);
                            doc.moveTo(LEFT_MARGIN, doc.y).lineTo(RIGHT_MARGIN, doc.y).strokeColor(COLOR_BORDER).lineWidth(0.2).stroke();
                            doc.moveDown(0.5);
                        });

                    } else {
                        // --- STANDARD ITEM RENDERING ---
                        unitItems.forEach(item => {
                            if (doc.y > 750) doc.addPage().y = 40;

                            const xOff = item.level > 0 ? 15 : 0;
                            const startY = doc.y;

                            const qtyStr = (item.quantity || 1) > 1 ? ` (x${item.quantity})` : '';

                            // Check if name already starts with brand (case-insensitive) to prevent "ARRI ARRI"
                            const brandPattern = new RegExp(`^${item.brand}`, 'i');
                            const displayName = brandPattern.test(item.name)
                                ? item.name
                                : `${item.brand} ${item.name}`;

                            doc.fontSize(9).font('Inter').fillColor(COLOR_ACCENT).text(`${displayName}${qtyStr}`.toUpperCase(), LEFT_MARGIN + xOff, startY, { characterSpacing: 0.5 });

                            // --- VENICE 2 / SD COMPATIBILITY ALERT (AS REQUESTED) ---
                            if (item.category === 'SUP' && item.specs_json) {
                                try {
                                    const specs = JSON.parse(item.specs_json);
                                    const hostCam = data.find(i => i.assignedCam === item.assignedCam && i.category === 'CAM');

                                    if (hostCam && hostCam.brand.toLowerCase() === 'sony' && hostCam.model?.includes('Venice 2') && specs.media_type === 'SD') {
                                        doc.moveDown(0.2);
                                        doc.fontSize(7).font('Inter-Bold').fillColor('#FF3B30').text("ðŸš¨ HATA: VENICE 2 ANA KAYIT Ä°Ã‡Ä°N SD KART KULLANAMAZ! LÃœTFEN AXS KART SEÃ‡Ä°N.", LEFT_MARGIN + xOff, doc.y);
                                    }
                                } catch (e) { }
                            }

                            const specsList: string[] = [];
                            if (item.sensor_size) specsList.push(item.sensor_size.toLowerCase());
                            if (item.weight_kg) specsList.push(`${item.weight_kg}kg`);
                            if (item.front_diameter_mm) specsList.push(`${item.front_diameter_mm}mm`);

                            if (specsList.length > 0) {
                                doc.fontSize(7).font('Inter').fillColor(COLOR_GREY_LIGHT).text(specsList.join(' â€¢ '), LEFT_MARGIN + xOff, doc.y);
                            }

                            doc.moveDown(0.5);
                            doc.moveTo(LEFT_MARGIN + xOff, doc.y).lineTo(RIGHT_MARGIN, doc.y).strokeColor(COLOR_BORDER).lineWidth(0.2).stroke();
                            doc.moveDown(0.5);
                        });
                    }
                });
            });

            // End Document
            doc.end();

            stream.on('finish', function () {
                const blob = stream.toBlob('application/pdf');
                const url = URL.createObjectURL(blob);
                resolve(url);
            });

            stream.on('error', (err) => reject(err));

        } catch (error) {
            reject(error);
        }
    });
}
